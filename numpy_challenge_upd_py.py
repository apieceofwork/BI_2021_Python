# -*- coding: utf-8 -*-
"""numpy_challenge_upd.py

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1XHEJneVVUSc4H8NSkeE70HMY8rG5f5Rc

### 1 C–æ–∑–¥–∞—Ç—å 3 –≤–∞—à–∏—Ö –ª—é–±–∏–º—ã—Ö —ç—Ä—Ä–µ—è —Ä–∞–∑–Ω—ã–º–∏ —Å–ø–æ—Å–æ–±–∞–º–∏
"""

import numpy as np

#1 –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞—Ç—å —Å–ø–∏—Å–æ–∫ –≤ –º–∞—Å—Å–∏–≤ –Ω–∞–º–ø–∞–π
food = ['banana', 'coffee', 'tiramisu', 'pasta', 'pizza']
food = np.array(food)

food

#2 c–¥–µ–ª–∞—Ç—å –º–∞—Å—Å–∏–≤ —á–µ—Ä–µ–∑ np.arange

birthdays_days = np.arange(2,100, 12)

birthdays_days

#3 –°–æ–∑–¥–∞—Ç—å —Å –Ω—É–ª—è –º–∞—Å—Å–∏–≤ –Ω–∞–º–ø–∞–π
family = np.array(['Masha', 'Varya', 'Papa', 'Mama', 'Babuska', 'Dedushka', 'Dyada Yura'])

family

"""## 2. –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏ —É–º–Ω–æ–∂–µ–Ω–∏—è –º–∞—Ç—Ä–∏—Ü

## –∑–¥–µ—Å—å –ø–æ–ø—Ä–∞–≤–∏—Ç—å —Ñ—É–Ω–∫—Ü–∏—é: –æ–Ω–∞ –¥–æ–ª–∂–Ω–∞ —É—á–∏—Ç—ã–≤–∞—Ç—å —Å–ø–∏—Å–æ–∫ –∏–∑ n-—ç–ª–µ–º–µ–Ω—Ç–æ–≤: - –ø–æ–ø—Ä–∞–≤–∏–ª–∞

*   –ö–æ–¥ —Å–∏–ª—å–Ω–æ –ø–µ—Ä–µ–≥—Ä—É–∂–µ–Ω
*   –ù–µ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ –∫–∞–∂–¥—ã–π —Ä–∞–∑ –≤—ã–∑—ã–≤–∞—Ç—å np.array, –µ—Å–ª–∏ —ç—Ç–æ –º–æ–∂–Ω–æ —Å–¥–µ–ª–∞—Ç—å –æ–¥–∏–Ω —Ä–∞–∑
*   –§—É–Ω–∫—Ü–∏—è –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –ª–æ–≥–∏—á–µ—Å–∫–∏–π —Ç–∏–ø, –ø–æ—ç—Ç–æ–º—É —É–ª–æ–≤–∏—è —Ç—É—Ç –ª–∏—à–Ω–∏–µ
*   –í 38 –∏ 44 —Å—Ç—Ä–æ–∫–∞—Ö —Ç—ã –ø—Ä–æ–≤–µ—Ä—è–µ—à—å —Ä–∞–∑–º–µ—Ä –º–∞—Ç—Ä–∏—Ü, –Ω–æ –ø–æ—á–µ–º—É-—Ç–æ –¥–µ–ª–∞–µ—à—å —ç—Ç–æ –ø–æ-—Ä–∞–∑–Ω–æ–º—É
"""

def multiplication_check(matrix_list):
  for i in range(len(matrix_list) - 1):
    matrixes = matrix_list[i:i+2]
    matrix1 = np.array(matrixes[0]) #–º–∞—Ç—Ä–∏—Ü–∞ 1 –∏–∑ –º–∞—Å—Å–∏–≤–∞
    matrix2 = np.array(matrixes[1]) #–º–∞—Ç—Ä–∏—Ü–∞ 2 –∏–∑ –º–∞—Å—Å–∏–≤–∞
    
    #—É–º–Ω–æ–∂–µ–Ω–∏–µ –¥–≤—É—Ö –Ω–µ–æ–¥–Ω–æ–º–µ—Ä–Ω—ã—Ö –∏–ª–∏ –ø–µ—Ä–≤–æ–≥–æ –Ω–µ–æ–¥–Ω–æ–º–µ—Ä–Ω–æ–≥–æ –∏ –≤—Ç–æ—Ä–æ–≥–æ –æ–¥–Ω–æ–º–µ—Ä–Ω–æ–≥–æ
    if (np.array(matrix1).ndim != 1 and np.array(matrix2).ndim != 1) or (np.array(matrix1).ndim != 1 and np.array(matrix2).ndim == 1):
      return np.shape(matrix1)[1] ==  np.shape(matrix2)[0]

     #–∫–æ–≥–¥–∞ –ø–µ—Ä–≤—ã–π –æ–¥–Ω–æ–º–µ—Ä–Ω—ã–π, –∞ –≤—Ç–æ—Ä–æ–π –Ω–µ–æ–¥–Ω–æ–º–µ—Ä–Ω—ã–π
    elif np.array(matrix1).ndim == 1 and np.array(matrix2).ndim != 1:
      return np.shape(matrix1)[0] == np.shape(matrix2)[0]
    
    #–∫–æ–≥–¥–∞ –æ–±–∞ –æ–¥–Ω–æ–º–µ—Ä–Ω—ã–µ
    elif np.array(matrix1).ndim == 1 and np.array(matrix2).ndim == 1:
      return matrix1.size == 1 and matrix2.size == 1

multiplication_check([[[1,2,2],[2,3,2],[1,2,3]],[13,1,3]])

"""## 3. –§—É–Ω–∫—Ü–∏—è –¥–ª—è —É–º–Ω–æ–∂–µ–Ω–∏—è - –ø–æ–ø—Ä–∞–≤–∏–ª–∞
–∑–¥–µ—Å—å: - –ø–æ–ø—Ä–∞–≤–ª–µ–Ω–æ
* –ø–æ–ø—Ä–∞–≤–∏—Ç—å –æ—Ç—Å—Ç—É–ø—ã 
* —É–±—Ä–∞—Ç—å –≤–µ–∑–¥–µ np.array
"""

def matrix_multiplication(matrix1,matrix2):
    matrix1_np = np.array(matrix1)
    if multiplication_check([matrix1_np, matrix2]) == True:
      product = matrix1_np.dot(np.array(matrix2))
      return product
    else:
      print('The matrices cannot be multiplied')

matrix_multiplication([[1,2,4],[1,3,4]],[12,4,4])

matrix_multiplication([1,2],[1,3])

matrix_multiplication([[1,2,4],[1,3,4]],[12,4,4])

"""## 4. –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ —Å–ø–∏—Å–∫–∞ –º–∞—Ç—Ä–∏—Ü - –ø–æ–ø—Ä–∞–≤–∏–ª–∞"""

def multiply_matrices(matrixes):

  if multiplication_check(matrixes): #–µ—Å–ª–∏ –≤–µ—Å—å —Å–ø–∏—Å–æ–∫ –º–∞—Ç—Ä–∏—Ü –ø—Ä–æ—Ö–æ–¥–∏—Ç –ø—Ä–æ–≤–µ—Ä–∫—É
    product = np.array(1)
    for i in range(len(matrixes) - 1):
      result = matrix_multiplication(matrixes[i], matrixes[i+1]) #–ø–æ–ø–∞—Ä–Ω–æ–µ –ø–µ—Ä–µ–º–Ω–æ–∂–µ–Ω–∏–µ 
      product = product.dot(result) #–ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ–µ —É–º–Ω–æ–∂–µ–Ω–∏–µ –ø–æ–¥–æ–±–Ω—ã—Ö –º–∞—Ç—Ä–∏—Ü-—Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ —É–º–Ω–æ–∂–µ–Ω–∏—è –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –∏—Ç–æ–≥–∞
  else:
    product = None

  return product

multiply_matrices([[[1,2,4],[1,3,4]],[12,4,4]])

"""## 5. –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–æ–¥—Å—á–µ—Ç–∞ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–π –º–µ–∂–¥—É –¥–≤—É–º—è —Ç–æ—á–∫–∞–º–∏ –≤ –¥–≤—É–º–µ—Ä–Ω–æ–º –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–µ

üëç
"""

def compute_2d_distance(point1, point2):
  a = np.array(point1)
  b = np.array(point2)
  distance = np.linalg.norm(a - b)
  return distance

"""## 6. –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–æ–¥—Å—á–µ—Ç–∞ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–π –º–µ–∂–¥—É –¥–≤—É–º—è —Ç–æ—á–∫–∞–º–∏ –≤ n-–º–µ—Ä–Ω–æ–º –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–µ

üëç
"""

def compute_multidimensional_distance(point1, point2):
  if len(point1) == len(point2):
    a_mult = np.array(point1)
    b_mult = np.array(point2)
    distance = np.linalg.norm(a_mult - b_mult)
    return distance
  else:
    print('the matrixes should have the same number of elements')

"""## 7. –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–æ–¥—Å—á–µ—Ç–∞ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–π –≤ –¥–≤—É–º–µ—Ä–Ω–æ–º –º–∞—Å—Å–∏–≤–µ

üëç
"""

def compute_pair_distances(matrix):
  matrix_arr = np.array(matrix)
  n = matrix_arr.shape[0]
  distances = np.zeros((n,n))
  for i in range(n):
    for j in range(n):
      distances[i][j] = np.linalg.norm(matrix_arr[i] - matrix_arr[j])

  return distances
# -*- coding: utf-8 -*-
"""numpy_challenge.py

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1XHEJneVVUSc4H8NSkeE70HMY8rG5f5Rc

### 1 Cоздать 3 ваших любимых эррея разными способами
"""

import numpy as np

#1 преобразовать список в массив нампай
food = ['banana', 'coffee', 'tiramisu', 'pasta', 'pizza']
food = np.array(food)

food

#2 cделать массив через np.arange

birthdays_days = np.arange(2,100, 12)

birthdays_days

#3 Создать с нуля массив нампай
family = np.array(['Masha', 'Varya', 'Papa', 'Mama', 'Babuska', 'Dedushka', 'Dyada Yura'])

family

"""## 2. Функция для проверки возможности умножения матриц"""

def multiplication_check(matrix_list):
  matrix1 = matrix_list[0]
  matrix2 = matrix_list[1]
  #умножение двух неодномерных или первого неодномерного и второго одномерного
  if (np.array(matrix1).ndim != 1 and np.array(matrix2).ndim != 1) or (np.array(matrix1).ndim != 1 and np.array(matrix2).ndim == 1):
    if np.shape(matrix1)[1] ==  np.shape(matrix2)[0]:
      return True
    else:
      return False
  #когда первый одномерный, а второй неодномерный
  elif np.array(matrix1).ndim == 1 and np.array(matrix2).ndim != 1:
    if np.array(matrix1).shape[0] == np.array(matrix2).shape[0]:
      return True
    else:
      return False
  elif np.array(matrix1).ndim == 1 and np.array(matrix2).ndim == 1:
    if np.array(matrix1).size == 1 and np.array(matrix2).size == 1:
      return True
    else:
      return False

"""## 3. Функция для умножения"""

def matrix_multiplication(matrix1,matrix2):
  if multiplication_check([matrix1, matrix2]) == True:
    product = np.array(matrix1).dot(np.array(matrix2))
    return product
  else:
    print('The matrices cannot be multiplied')

"""## 4. Функция для проверки списка матриц """

def multiply_matrices(matrixes_list):
  product = np.array(1)
  for i in range(len(matrixes_list) - 1):
    #в цикле берутся попарные матрицы внутри массива для умножения и попарно проверяются по правилу
    matrixes = matrixes_list[i:i+2]
    if multiplication_check(matrixes) == True: #проверка на условие умнножения
      result = matrix_multiplication(matrixes[i], matrixes[i+1]) #попарное перемножение 
      product = product.dot(result) #последовательное умножение подобных матриц-результатов умножения для получения итога
    else:
      product = None

  return product

"""## 5. Функция для подсчета расстояний между двумя точками в двумерном пространстве"""

def compute_2d_distance(point1, point2):
  a = np.array(point1)
  b = np.array(point2)
  distance = np.linalg.norm(a - b)
  return distance

"""## 6. Функция для подсчета расстояний между двумя точками в n-мерном пространстве"""

def compute_multidimensional_distance(point1, point2):
  if len(point1) == len(point2):
    a_mult = np.array(point1)
    b_mult = np.array(point2)
    distance = np.linalg.norm(a_mult - b_mult)
    return distance
  else:
    print('the matrixes should have the same number of elements')

"""## 7. Функция для подсчета расстояний в двумерном массиве"""

def compute_pair_distances(matrix):
  matrix_arr = np.array(matrix)
  n = matrix_arr.shape[0]
  distances = np.zeros((n,n))
  for i in range(n):
    for j in range(n):
      distances[i][j] = np.linalg.norm(matrix_arr[i] - matrix_arr[j])

  return distances